import cog

def get_warning_comment(class_name):
    return f'// Auto generated code. See class document of {class_name}.'

def declare_begin(module, header=True):
    class_name = module.ClassName
    namespace = module.NameSpace
    params = module.Params
    param_path = module.ParamPath
    param_file = getattr(module, 'ParamFile', module.ClassName + '.py')
    header_file = getattr(module, 'HeaderFile', module.ClassName + '.h')
    source_file = getattr(module, 'SourceFile', module.ClassName + '.cpp')
    class_doc = module.ClassDoc

    if header:
        cog.out(f'''
#include <Base/Parameter.h>
''')

    cog.out(f'''
namespace {namespace} {{
/** {class_doc}

 * The parameters are under group "{param_path}"
 *
 * This class is auto generated by {class_name}.py. Modify that file
 * instead of this one, if you want to add any parameter. You need
 * to install Cog Python package for code generation:
 * @code
 *     pip install cogapp
 * @endcode
 *
 * Once modified, you can regenerate the header and the source file,
 * @code
 *     python3 -m cogapp -r {header_file} {source_file}
 * @endcode
 *
 * You can add a new parameter by adding lines in {param_file}. Available
 * parameter types are 'Int, UInt, String, Bool, Float'. For example, to add
 * a new Int type parameter,
 * @code
 *     ParamInt(parameter_name, default_value, documentation, on_change=False)
 * @endcode
 *
 * If there is special handling on parameter change, pass in on_change=True.
 * And you need to provide a function implementation in {source_file} with
 * the following signature.
 * @code
 *     void {class_name}:on<parameter_name>Changed()
 * @endcode
 */
class {namespace}Export {class_name} {{
public:
    static ParameterGrp::handle getHandle();
''')

    for param in params:
        cog.out(f'''
    //@{{
    /// Accessor for parameter {param.name}''')
        if param._doc:
            cog.out(f'''
    ///''')
            for line in param._doc.split('\n'):
                cog.out(f'''
    /// {line}''')
        cog.out(f'''
    static const {param.C_Type} & get{param.name}();
    static const {param.C_Type} & default{param.name}();
    static void remove{param.name}();
    static void set{param.name}(const {param.C_Type} &v);
    static const char *doc{param.name}();''')
        if param.on_change:
            cog.out(f'''
    static void on{param.name}Changed();''')
        cog.out(f'''
    //@}}
''')


def declare_end(module):
    class_name = module.ClassName
    namespace = module.NameSpace
    warning_comment = get_warning_comment(class_name)

    cog.out(f'''
    {warning_comment}
}};
}} // namespace {namespace}
''')


def define(module, header=True):
    class_name = module.ClassName
    namespace = module.NameSpace
    params = module.Params
    param_path = module.ParamPath
    class_doc = module.ClassDoc
    warning_comment = get_warning_comment(class_name)

    if header:
        cog.out(f'''
{warning_comment}
#include <unordered_map>
#include <App/Application.h>
#include <App/DynamicProperty.h>
#include "{class_name}.h"
using namespace {namespace};
''')

    cog.out(f'''
namespace {{

{warning_comment}
class {class_name}P: public ParameterGrp::ObserverType {{
public:
    {warning_comment}
    ParameterGrp::handle handle;

    {warning_comment}
    std::unordered_map<const char *,void(*)({class_name}P*),App::CStringHasher,App::CStringHasher> funcs;
''')

    for param in params:
        cog.out(f'''
    {param.C_Type} {param.name}; {warning_comment}''')

    cog.out(f'''

    {warning_comment}
    {class_name}P() {{
        handle = App::GetApplication().GetParameterGroupByPath("{param_path}");
        handle->Attach(this);
''')

    for param in params:
        cog.out(f'''
        {param.name} = handle->Get{param.Type}("{param.name}", {param.default});
        funcs["{param.name}"] = &{class_name}P::update{param.name};''')

    cog.out(f'''
    }}

    {warning_comment}
    ~{class_name}P() {{
    }}

    {warning_comment}
    void OnChange(Base::Subject<const char*> &, const char* sReason) {{
        if(!sReason)
            return;
        auto it = funcs.find(sReason);
        if(it == funcs.end())
            return;
        it->second(this);
    }}

''')

    for param in params:
        if not param.on_change:
            cog.out(f'''
    {warning_comment}
    static void update{param.name}({class_name}P *self) {{
        self->{param.name} = self->handle->Get{param.Type}("{param.name}", {param.default});
    }}''')
        else:
            cog.out(f'''
    {warning_comment}
    static void update{param.name}({class_name}P *self) {{
        auto v = self->handle->Get{param.Type}("{param.name}", {param.default});
        if (self->{param.name} != v) {{
            self->{param.name} = v;
            {class_name}::on{param.name}Changed();
        }}
    }}''')

    cog.out(f'''
}};

{warning_comment}
{class_name}P *instance() {{
    static {class_name}P *inst = new {class_name}P;
    return inst;
}}

}} // Anonymous namespace

{warning_comment}
ParameterGrp::handle {class_name}::getHandle() {{
    return instance()->handle;
}}
''')

    for param in params:
        cog.out(f'''
{warning_comment}
const char *{class_name}::doc{param.name}() {{
    return {param.doc(class_name)};
}}

{warning_comment}
const {param.C_Type} & {class_name}::get{param.name}() {{
    return instance()->{param.name};
}}

{warning_comment}
const {param.C_Type} & {class_name}::default{param.name}() {{
    const static {param.C_Type} def = {param.default};
    return def;
}}

{warning_comment}
void {class_name}::set{param.name}(const {param.C_Type} &v) {{
    instance()->handle->Set{param.Type}("{param.name}",v);
    instance()->{param.name} = v;
}}

{warning_comment}
void {class_name}::remove{param.name}() {{
    instance()->handle->Remove{param.Type}("{param.name}");
}}
''')

class Param:
    def __init__(self, name, default, doc='', on_change=False):
        self.name = name
        self._default = default
        self._doc = doc
        self.on_change = on_change

    @property
    def default(self):
        return self._default

    def doc(self, class_name):
        if not self._doc:
            return '""'

        def quote(txt):
            lines = [ '"' + l.replace('"', '\"').replace('\\', '\\\\') for l in txt.split('\n')]
            return '\\n"\n'.join(lines) + '"'

        return f'''QT_TRANSLATE_NOOP("{class_name}",
{quote(self._doc)})'''

class ParamBool(Param):
    Type = 'Bool'
    C_Type = 'bool'

    @property
    def default(self):
        if isinstance(self._default, str):
            return self._default
        return 'true' if self._default else 'false'

class ParamFloat(Param):
    Type = 'Float'
    C_Type = 'double'

class ParamString(Param):
    Type = 'ASCII'
    C_Type = 'std::string'

    @property
    def default(self):
        return f'"{self._default}"'

class ParamInt(Param):
    Type = 'Int'
    C_Type = 'long'

class ParamUInt(Param):
    Type = 'Unsigned'
    C_Type = 'unsigned long'

